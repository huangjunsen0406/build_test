name: Setup and Build for Windows and Linux

on:
  push:
    branches:
      - main

env:
  PYTHONIOENCODING: utf-8
  PYTHONUTF8: 1
  # 设置默认编码为UTF-8
  LC_ALL: C.UTF-8
  LANG: C.UTF-8

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      # 检出代码
      - name: 检出代码
        uses: actions/checkout@v4

      # 安装 Inno Setup
      - name: 安装 Inno Setup（通过 Chocolatey）
        run: choco install innosetup -y
        shell: powershell

      # 下载 ChineseSimplified.isl 文件
      - name: 下载中文语言文件
        run: |
          $languageDir = "C:\Program Files (x86)\Inno Setup 6\Languages"
          
          # 确保目录存在
          if (-not (Test-Path $languageDir)) {
            New-Item -ItemType Directory -Path $languageDir -Force
          }
          
          # 下载中文语言文件
          Invoke-WebRequest -Uri "https://raw.githubusercontent.com/jrsoftware/issrc/main/Files/Languages/Unofficial/ChineseSimplified.isl" -OutFile "$languageDir\ChineseSimplified.isl"
          
          Write-Host "已下载中文语言文件到 $languageDir\ChineseSimplified.isl"
          
          # 验证文件是否存在
          if (Test-Path "$languageDir\ChineseSimplified.isl") {
            Write-Host "文件下载成功！"
          } else {
            Write-Error "文件下载失败！"
            exit 1
          }
        shell: powershell

      # 查找 ISCC.exe 路径并更新 build.json
      - name: 查找 ISCC.exe 路径并更新 build.json
        run: |
          # 获取 ISCC 路径
          $isccPath = Get-Command ISCC.exe | Select-Object -ExpandProperty Source

          # 设置环境变量
          $envLine = "ISCC_PATH=$($isccPath -replace '`r','' -replace '`n','')"
          [System.IO.File]::AppendAllText($env:GITHUB_ENV, "$envLine`n", [System.Text.Encoding]::UTF8)

          # 读取 JSON 内容
          $jsonPath = "build.json"
          $json = Get-Content $jsonPath -Raw | ConvertFrom-Json

          # 设置新的 Inno Setup 路径
          $json.inno_setup_path = $isccPath

          # 写回 JSON 文件，使用不带 BOM 的 UTF-8
          $json | ConvertTo-Json -Depth 10 | Set-Content -Path $jsonPath -Encoding utf8

          Write-Host "已更新 build.json 中的 Inno Setup 路径为: $isccPath"
        shell: powershell

      # 安装 Miniconda 和 Conda
      - name: 安装 Miniconda 和 Conda
        uses: conda-incubator/setup-miniconda@v3
        with:
          python-version: "3.10"
          auto-update-conda: true
          auto-activate-base: false
          activate-environment: py-xiaozhi

      # 安装 Python 依赖（pip + conda + pyinstaller）
      - name: 安装 Python 依赖（pip + conda + pyinstaller）
        shell: bash -el {0}
        run: |
          conda activate py-xiaozhi
          
          # 安装依赖
          pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple

          pip uninstall numpy -y

          conda install pyqt=5.15.10 opencv=4.10.0 -y
          
          # 安装 PyInstaller (使用特定版本)
          pip install pyinstaller==6.13.0 wmi -i https://mirrors.aliyun.com/pypi/simple
          
          # 安装 Opus 库
          pip install opuslib -i https://mirrors.aliyun.com/pypi/simple
          
          conda install numpy=1.24.3 -y

      # 创建与本地环境类似的目录结构
      - name: 创建工作目录结构
        run: |
          mkdir -p ../UnifyPy
          git clone https://github.com/huangjunsen0406/UnifyPy.git ../UnifyPy
        shell: bash

      # 运行 UnifyPy 构建项目，使用类似本地的路径结构
      - name: 运行 UnifyPy 构建项目
        shell: bash -el {0}
        run: |
          conda activate py-xiaozhi
          export PYTHONIOENCODING=utf-8
          export PYTHONUTF8=1
          export PYTHONUNBUFFERED=1  # 确保Python输出不被缓冲
          python -u ../UnifyPy/main.py . --config ./build.json  # 添加-u参数禁用输出缓冲

      # 重命名Windows安装程序为指定格式
      - name: 重命名Windows安装程序
        shell: powershell
        run: |
          # 读取版本号
          $jsonPath = "build.json"
          $json = Get-Content $jsonPath -Raw | ConvertFrom-Json
          $version = $json.version
          $name = $json.name
          
          # 创建installer目录（如果不存在）
          if (-not (Test-Path "installer")) {
            New-Item -ItemType Directory -Path "installer" -Force
          }
          
          # 查找安装程序文件
          $setupFiles = Get-ChildItem -Path "installer" -Filter "*setup.exe"
          
          if ($setupFiles.Count -gt 0) {
            foreach ($file in $setupFiles) {
              $newName = "${name}_${version}_x64-setup.exe"
              $newPath = Join-Path "installer" $newName
              
              # 重命名文件
              Move-Item -Path $file.FullName -Destination $newPath -Force
              Write-Host "已将安装程序重命名为: $newName"
            }
          } else {
            Write-Host "未找到安装程序文件"
          }

      # 只上传 Inno Setup 安装程序
      - name: 上传安装程序
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer
          path: installer/

      # 上传调试信息 (在失败情况下也执行)
      - name: 上传调试信息
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-debug-info
          path: |
            build.json
            dist/
            xiaozhi.spec
          continue-on-error: true

      # 检查构建结果
      - name: 检查构建结果
        if: always()
        shell: bash
        run: |
          echo "检查dist目录内容:"
          ls -la dist/ || echo "dist目录不存在"
          
          echo "检查installer目录内容:"
          ls -la installer/ || echo "installer目录不存在"
          
          echo "检查是否存在关键文件夹:"
          ls -la assets/ || echo "assets文件夹不存在"
          ls -la libs/ || echo "libs文件夹不存在"
          ls -la src/ || echo "src文件夹不存在"

  build-linux:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        arch: [x64, arm64, arm]
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 QEMU（仅用于非 x64 架构）
        if: matrix.arch != 'x64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.arch }}

      - name: 使用 Docker 构建 ${{ matrix.arch }} 架构
        run: |
          ARCH=${{ matrix.arch }}
          DOCKERFILE="Dockerfile.${ARCH}"

          # 准备 Dockerfile
          if [[ "$ARCH" == "x64" ]]; then
            BASE_IMAGE="ubuntu:20.04"
            MINIFORGE_URL="https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh"
          elif [[ "$ARCH" == "arm64" ]]; then
            BASE_IMAGE="arm64v8/ubuntu:20.04"
            MINIFORGE_URL="https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-aarch64.sh"
          elif [[ "$ARCH" == "arm" ]]; then
            BASE_IMAGE="arm32v7/ubuntu:20.04"
            MINIFORGE_URL="https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-armv7l.sh"
          else
            echo "不支持的架构：$ARCH"
            exit 1
          fi

          cat > $DOCKERFILE <<EOF
          FROM $BASE_IMAGE
          ENV DEBIAN_FRONTEND=noninteractive
          ENV PYTHONIOENCODING=utf-8
          ENV PYTHONUTF8=1
          ENV LC_ALL=C.UTF-8
          ENV LANG=C.UTF-8
          RUN apt-get update && apt-get install -y \\
              build-essential \\
              python3-dev python3-pip python3-setuptools \\
              libopenblas-dev liblapack-dev gfortran \\
              patchelf autoconf automake libtool \\
              cmake libssl-dev libatlas-base-dev dpkg-dev \\
              git wget && apt-get clean
          RUN wget $MINIFORGE_URL -O miniconda.sh \\
              && bash miniconda.sh -b -p /opt/conda \\
              && rm miniconda.sh
          ENV PATH="/opt/conda/bin:\$PATH"
          WORKDIR /app
          COPY . /app/
          RUN conda create -n py-xiaozhi python=3.10 -y
          SHELL ["/bin/bash", "-c"]
          RUN source /opt/conda/bin/activate py-xiaozhi \\
              && pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple \\
              && pip uninstall numpy -y \\
              && conda install pyqt=5.15.10 opencv=4.10.0 -y \\
              && pip install pyinstaller==6.13.0 opuslib -i https://mirrors.aliyun.com/pypi/simple \\
              && export BLAS=openblas \\
              && export LAPACK=openblas \\
              && export NPY_NUM_BUILD_JOBS=\$(nproc) \\
              && pip install numpy==1.24.3 --no-binary :all:
          RUN git clone https://github.com/huangjunsen0406/UnifyPy.git /UnifyPy
          CMD source /opt/conda/bin/activate py-xiaozhi \\
              && python -u /UnifyPy/main.py . --config ./build.json
          EOF

          docker build -t unifypy-${ARCH}-builder -f $DOCKERFILE .
          docker run --rm -v $(pwd):/app unifypy-${ARCH}-builder

      - name: 重命名安装包
        run: |
          VERSION=$(python3 -c "import json; print(json.load(open('build.json'))['version'])")
          NAME=$(python3 -c "import json; print(json.load(open('build.json'))['name'])")
          mkdir -p installer
          for file in installer/*; do
            ext="${file##*.}"
            if [[ -f "$file" ]]; then
              new_name="${NAME}_${VERSION}_${{ matrix.arch }}.${ext}"
              mv "$file" "installer/$new_name"
              echo "已重命名安装包: $new_name"
            fi
          done
          ls -la installer/

      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ matrix.arch }}-installer
          path: installer/

      - name: 上传调试信息
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ matrix.arch }}-debug-info
          path: |
            build.json
            dist/
            xiaozhi.spec
          continue-on-error: true


